#!/usr/bin/python
# -*- coding: utf-8 -*-
# vim: set syntax=python

from __future__ import print_function

import sys
import os
import re
import copy
import socket
import time
from optparse import OptionParser


def error(s, **kw):
    print('\033[91m%s\033[0m' % s, **kw)
    sys.stdout.flush()


def info(s, **kw):
    print('\033[92m%s\033[0m' % s, **kw)
    sys.stdout.flush()


def warn(s, **kw):
    print('\033[95m%s\033[0m' % s, **kw)
    sys.stdout.flush()


class ParseError(Exception):
    def __init__(self, fpath, line_no, line):
        self.fpath = fpath
        self.line_no = line_no
        self.line = line


# filters

def http_wrap(s, unused):
    parts = s.split('\n')
    i = next((i for i, v in enumerate(parts) if v == ''), len(parts))
    header = '\r\n'.join(l for l in parts[:i])
    body = '\n'.join(l for l in parts[i+1:])
    return '%s\r\n\r\n%s' % (header, body)


def http_strip_body(s, unused):
    parts = s.split('\r\n')
    i = next((i for i, v in enumerate(parts) if v == ''), len(parts))
    return parts[:i]


def http_strip_header(s, unused):
    parts = s.split('\r\n')
    i = next((i for i, v in enumerate(parts) if v == ''), len(parts))
    return ''.join(parts[i+1:])


def python_exec(s, e):
    exec(s, None, e)
    return s


class Block(object):
    FILTERS = {
        'http': http_wrap,
        'http_strip_body': http_strip_body,
        'http_strip_header': http_strip_header,
        'python': python_exec,
    }
    DEFAULT_FILTER = {
        'request': 'http',
        'response': 'http_strip_body',
        'response_body': 'http_strip_header',
        'setup': 'python',
        'teardown': 'python',
    }

    def __init__(self, head, lines):
        head = re.sub('\s', '', head)
        heads = head.split('|')
        self.name = heads[0]
        self.filters = heads[1:]

        # set default filter
        default_flt = self.DEFAULT_FILTER.get(self.name)
        if default_flt and not self.filters:
            self.filters.append(default_flt)

        # strip empty lines
        i, j = 0, len(lines) - 1
        while i <= j and lines[i].strip() == '':
            i += 1
        while i <= j and lines[j].strip() == '':
            j -= 1
        self.lines = [l.rstrip() for l in lines[i:j+1]]

    def __str__(self):
        if self.filters:
            return '<Block, name=%s, filters=%s>' % (self.name, '|'.join(self.filters))
        return '<Block, name=%s>' % (self.name)

    def __repr__(self):
        return self.__str__()

    @property
    def raw_content(self):
        return '\n'.join(self.lines)

    def filter(self, env, raw_content=None):
        content = self.raw_content if raw_content is None else raw_content
        for flt in self.filters:
            if flt == 'raw':
                continue
            flt_func = env.get(flt) or self.FILTERS.get(flt)
            if not flt_func:
                raise Exception('Can not find filter \'%s\'' % flt)
            try:
                content = flt_func(content, env)
            except Exception as e:
                raise e
        return content


class Case(object):
    def __init__(self, name):
        self.name = name
        self.blocks = {}

    def set_block(self, block):
        self.blocks[block.name] = block

    def get_block(self, name):
        return self.blocks.get(name)

    def __str__(self):
        return '<Case, %s>' % (self.name)

    def __repr__(self):
        return self.__str__()


def parse_file(fpath):
    cases = []
    env_lines = []
    block_lines = []
    block_head = None
    case = None
    block = None

    st_env, st_case, st_block = range(3)
    st = st_env
    line_no = 0

    with open(fpath, 'r') as f:
        for line in f:
            line_no += 1
            if st != st_env and line.strip().startswith('#'):
                continue

            if line.startswith('==='):
                if case:
                    if block_head:
                        block = Block(block_head, block_lines)
                        case.set_block(block)
                    cases.append(case)
                case = Case(line[3:].strip())
                st = st_case
            elif line.startswith('---'):
                if st != st_case and st != st_block:
                    raise ParseError(fpath, line_no, line)
                if block_head:
                    block = Block(block_head, block_lines)
                    case.set_block(block)
                block_head = line[3:].strip()
                block_lines = []
                st = st_block
            elif st == st_env:
                env_lines.append(line)
            elif st == st_block:
                block_lines.append(line)
            elif line.strip():
                raise ParseError(fpath, line_no, line)
        if case:
            if block_head:
                block = Block(block_head, block_lines)
                case.set_block(block)
            cases.append(case)

    return env_lines, cases


def gather_files(test_dir):
    test_files = []
    if os.path.isdir(test_dir):
        for d, _, files in os.walk(test_dir):
            test_files.extend(os.path.join(d, f) for f in files
                    if f.endswith('yt'))
    else:
        test_files = [test_dir] if test_dir.endswith('yt') else []

    return test_files


def gather_cases(test_files, filter=None):
    test_cases = []
    for fpath in test_files:
        env = {'sys': sys}
        try:
            env_lines, cases = parse_file(fpath)
            if env_lines:
                exec(''.join(env_lines), None, env)
        except ParseError as e:
            warn('ParseError in %s:%s, invalid line: %s' % \
                    (e.fpath, e.line_no, e.line))
        except NameError as e:
            warn('NameError in %s: %s' % (fpath, e.message))
        except SyntaxError as e:
            warn("SyntaxError in python block %s:%s" % \
                    (fpath, e.lineno))
        except Exception as e:
            warn('Exception in %s: %s' % (fpath, str(e)))
        else:
            if filter:
                cs = [c for c in cases if re.findall(filter, c.name)]
                if cs:
                    test_cases.append((fpath, (env, cs)))
            else:
                test_cases.append((fpath, (env, cases)))

    return test_cases


class Server(object):

    STOP_SRV = 'nginx/sbin/nginx -s stop > /dev/null 2>&1 || ps aux | grep nginx | grep -v grep | awk \'{print $2}\' | xargs kill -9 > /dev/null 2>&1'
    START_SRV = 'nginx/sbin/nginx 1> /dev/null'
    RELOAD_SRV = 'nginx/sbin/nginx -s reload 1> /dev/null'
    LOG_PATH = 'nginx/logs/error.log'
    ERR_PAT = '.+\[error\]'
    WARN_PAT = '.+\[warn\]'

    def __init__(self, env):
        self.env = env
        self.log_path = env.get('LOG_PATH', self.LOG_PATH)

    def stop(self):
        os.system(self.env.get('STOP_SERVER', self.STOP_SRV))

    def start(self):
        self.stop()
        os.system(self.env.get('START_SERVER', self.START_SRV))
        if os.path.exists(self.log_path):
            os.system('> %s' % self.log_path)

    def reload(self):
        os.system(self.env.get('RELOAD_SERVER', self.RELOAD_SRV))

    def grep_log(self, level='error'):
        pat = re.compile(self.ERR_PAT if level == 'error' else self.WARN_PAT)
        logs = []
        with open(self.log_path, 'r') as f:
            logs = [l for l in f if pat.match(l)]
        return logs


def send_request(endpoint, body, max_body=1024*1024, timeout=5):
    host, port = endpoint.split(':') if ':' in endpoint else (endpoint, 80)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    sock.connect((host, int(port)))
    sock.send(body)
    resp = sock.recv(max_body)
    sock.close()
    return resp


def run_case(env, case):
    srv = Server(env)
    not_match = lambda exp, got: 'expect %r but got %r' % (exp, got)
    def _check_log(level):
        blk = case.get_block(level)
        if not blk:
            return
        lines = [l for l in blk.lines if l.strip()]
        log_lines = srv.grep_log(level=level)

        err_prefix = 'grep %s failed, ' % level
        if len(lines) != len(log_lines):
            return err_prefix + not_match(lines, log_lines)
        for idx, line in enumerate(lines):
            if not re.match(line, log_lines[idx]):
                return err_prefix + not_match(line, log_lines[idx])

    srv.start()

    setup_blk = case.get_block('setup')
    if setup_blk:
        setup_blk.filter(env)

    teardown_blk = case.get_block('teardown')

    request_blk = case.get_block('request')
    if request_blk:
        content = request_blk.filter(env)
        endpoint = env.get('ENDPOINT', '127.0.0.1')
        resp = send_request(endpoint, content)

        response_blk = case.get_block('response')
        if response_blk:
            expect = [l.strip() for l in response_blk.lines]
            got = response_blk.filter(env, resp)
            for line in expect:
                if line in got:
                    continue
                # if not in got, try re
                pat = re.compile('^%s$' % line)
                if any(l for l in got if pat.match(l)):
                    continue
                if teardown_blk:
                    teardown_blk.filter(env)
                srv.stop()
                return not_match('\n'.join(expect), got)
        response_body_blk = case.get_block('response_body')
        if response_body_blk:
            expect = response_body_blk.raw_content
            got = response_body_blk.filter(env, resp)
            if expect != got:
                if teardown_blk:
                    teardown_blk.filter(env)
                srv.stop()
                return not_match(expect, got)

    if teardown_blk:
        teardown_blk.filter(env)

    srv.stop()

    err = _check_log('error') or _check_log('warn')
    if err:
        return err


def main():
    parser = OptionParser()
    parser.add_option("-k", "--filter", dest="filter",
                      help="file pattern to run")
    options, args = parser.parse_args()

    test_dir = args[0] if args else 'tests'
    sys.path.append(test_dir)

    test_files = gather_files(test_dir)
    test_cases = gather_cases(test_files, options.filter)

    total_cases = sum(len(c) for f, (e, c) in test_cases)
    info('%s test case(s) gathered.' % total_cases)

    failed_cases = []
    for fpath, (file_env, cases) in test_cases:
        case_num = len(cases)
        num_width = len(str(case_num))
        info('%s\t...............\t0/%s%s' % \
                (fpath, case_num, '\b' * (num_width + 2)), end='')

        for idx, case in enumerate(cases):
            back_wdith = num_width + 1 + len(str(idx + 1))
            info('%s/%s%s' % (idx + 1, case_num, '\b' * back_wdith),
                    end='')

            time.sleep(0.1)
            case_env = copy.copy(file_env)
            try:
                err = run_case(case_env, case)
                if err:
                    error('%s:%s, %s' % (fpath, case.name, err))
                    failed_cases.append((fpath, case.name, err))
            except Exception as e:
                error(str(e))
                failed_cases.append((fpath, case.name, str(e)))
        info('\n')
    info('=' * 50)
    if not failed_cases:
        info('all test case(s) passed.')
    else:
        error('%s/%s test case(s) failed.' % (len(failed_cases), total_cases))
        for fpath, name, err in failed_cases:
            error('%s:%s, %s' % (fpath, name, err))


if __name__ == '__main__':
    main()
